#include "header.h"
#include "leks.h"

// func_Leks - Лексический блок
//__________________________________________________________________
// ВХОД:  string translit_result - строка после транслитерации
//__________________________________________________________________
// ВЫХОД: string result - результат лексического анализа
//__________________________________________________________________
string func_Leks(string translit_result) {
	// переменные для разбора результатов транслитерации
	char text[80];
	string leks[80];

	// результат транслитерации
	int length = parse_translit_result(translit_result, text, leks);

	// вызов функции анализатора
	return func_analyze(text, leks, length);
}

string func_analyze(char text[], string tr_keys[], int length) {
	int curState = BEGIN, ind = 0;
	string result_string = "";
	Token tkn;

	if (state_begin(text, tr_keys, &curState, &ind, &tkn) == 0)
		token_to_string(&result_string, &tkn);
	else cout << "ОШИБКА";

	if (state_space1(text, tr_keys, &curState, &ind, &tkn) == 0)
		token_to_string(&result_string, &tkn);
	else cout << "ОШИБКА";

	if (state_space2(text, tr_keys, &curState, &ind, &tkn) == 0)
		token_to_string(&result_string, &tkn);
	else cout << "ОШИБКА";

	if (state_space3(text, tr_keys, &curState, &ind, &tkn) == 0)
		token_to_string(&result_string, &tkn);
	else cout << "ОШИБКА";

	if (state_space4(text, tr_keys, &curState, &ind, &tkn) == 0)
		token_to_string(&result_string, &tkn);
	else cout << "ОШИБКА";

	if (state_name1(text, tr_keys, &curState, &ind, &tkn) == 0) {
		token_to_string(&result_string, &tkn);
		tkn.input_string = "(";
		tkn.leks = "ОСКОБКА";
		token_to_string(&result_string, &tkn);
	}
	else cout << "ОШИБКА";

	if (state_id3(text, tr_keys, &curState, &ind, &tkn) == 0) {
		token_to_string(&result_string, &tkn);
		tkn.input_string = ")";
		tkn.leks = "ЗСКОБКА";
		token_to_string(&result_string, &tkn);
	}
	else cout << "ОШИБКА";

	if (state_cbracket1(text, tr_keys, &curState, &ind, &tkn) == 0)
		token_to_string(&result_string, &tkn);
	else cout << "ОШИБКА";

	if (curState != SEMICOLON)
	{
		if (state_space6(text, tr_keys, &curState, &ind, &tkn) == 0) {
			token_to_string(&result_string, &tkn);
			tkn.input_string = "(";
			tkn.leks = "ОСКОБКА";
			token_to_string(&result_string, &tkn);
		}
		else cout << "ОШИБКА";

		if (state_sign_and_int(text, tr_keys, &curState, &ind, &tkn) == 0) {
			token_to_string(&result_string, &tkn);
			tkn.input_string = ")";
			tkn.leks = "ЗСКОБКА";
			token_to_string(&result_string, &tkn);
		}
		else cout << "ОШИБКА";

		if (state_cbracket2(text, tr_keys, &curState, &ind, &tkn) == 0)
			result_string.append("(" + tkn.input_string + ", " + tkn.leks + ")");
		else cout << "ОШИБКА";
	}

	if (ind <= length - 1 && state_semicolon(text, tr_keys, &curState, &ind, &tkn) != 0)
		cout << "ОШИБКА";

	return result_string;
}

void token_to_string(string *str, Token *tkn)
{
	(*str).append("(" + tkn->input_string + ", " + tkn->leks + "), ");
	tkn->input_string = "";
	tkn->leks = "";
}

int parse_translit_result(string translit_result, char text[], string tr_keys[]) {
	// индекс рассматриваемого символа, индекс текущего символа в
	// строке результата транслитерации
	int ind = 0, cur = 1;

	// цикл по строке с результатом транслитерации для сохранения 
	// лексем
	while (cur < translit_result.size()) {
		// запоминаем рассматриваемый символ
		text[ind] = translit_result[cur];

		// циклом считываем лексему (от запятой до скобки)
		int i = cur + 2;
		for (; translit_result[i] != ')'; i++)
			tr_keys[ind].push_back(translit_result[i]);

		// переход к следующему символу
		cur = i + 4;
		ind++;
	}
	return ind;
}

int state_begin(char symb[], string value[], int* curState, int* ind, Token* tkn) {
	if (*curState == BEGIN) {
		if (value[*ind] == "ПРОБЕЛ") {
			*ind++;
			return state_begin(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "БУКВА"){
			*curState = IF;
			return state_if(symb, value, curState, ind, tkn);
		}
		return -1;
	}
	return -1;
}

int state_if(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString) {
	if (*curState == IF) {
		if (value[*ind] == "БУКВА") {
			if (curString == "" && (char)tolower(symb[*ind]) == 'i') {
				curString.push_back(symb[*ind]);
				*ind += 1;
				return state_if(symb, value, curState, ind, tkn, curString);
			}
			if (curString.size() == 1 && (char)tolower(symb[*ind]) == 'f') {
				curString.push_back(symb[*ind]);
				*ind += 1;
				return state_if(symb, value, curState, ind, tkn, curString);
			}
			return -1;
		}
		if (curString.size() == 2 && value[*ind] == "ПРОБЕЛ") {
			*curState = SPACE1;
			tkn->input_string = curString;
			tkn->leks = "ИДЕНТИФИКАТОР";
			return 0;
		}
		return -1;
	}
	return -1;
}

int state_space1(char symb[], string value[], int* curState, int* ind, Token* tkn) {
	if (*curState == SPACE1) {
		if (value[*ind] == "ПРОБЕЛ") {
			(*ind)++;
			return state_space1(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "БУКВА") {
			*curState = ID1;
			return state_id1(symb, value, curState, ind, tkn);
		}
		return -1;
	}
	return -1;
}

int state_id1(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString) {
	if (*curState == ID1) {
		if (curString != "" && value[*ind] == "ПРОБЕЛ")
		{
			*curState = SPACE2;
			tkn->input_string = curString;
			tkn->leks = "ИДЕНТИФИКАТОР";
			return 0;
		}
		if (value[*ind] == "БУКВА" || value[*ind] == "ПОДЧЕРК" || value[*ind] == "ЦИФРА" && curString != "")
		{
			curString.push_back(symb[*ind]);
			(*ind)++;
			return state_id1(symb, value, curState, ind, tkn, curString);
		}
		return -1;
	}
	return -1;
}

int state_space2(char symb[], string value[], int* curState, int* ind, Token* tkn)
{
	if (*curState == SPACE2) {
		if (value[*ind] == "ПРОБЕЛ") {
			(*ind)++;
			return state_space2(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "БУКВА") {
			*curState = THEN;
			return state_then(symb, value, curState, ind, tkn);
		}
		return -1;
	}
	return -1;
}

int state_then(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString)
{
	if (*curState == THEN) {
		if (value[*ind] == "БУКВА") {
			switch ((char)tolower(symb[*ind])) {
				case 't': if (curString.size() != 0) return -1;
					break;
				case 'h': if (curString.size() != 1) return -1;
					break;
				case 'e': if (curString.size() != 2) return -1;
					break;
				case 'n': if (curString.size() != 3) return -1;
					break;
				default: return -1;
			}
			curString.push_back(symb[*ind]);
			*ind += 1;
			return state_then(symb, value, curState, ind, tkn, curString);
		}
		if (curString.size() == 4 && value[*ind] == "ПРОБЕЛ") {
			*curState = SPACE3;
			tkn->input_string = curString;
			tkn->leks = "ИДЕНТИФИКАТОР";
			return 0;
		}
		return -1;
	}
	return -1;
}

int state_space3(char symb[], string value[], int* curState, int* ind, Token* tkn) {
	if (*curState == SPACE3) {
		if (value[*ind] == "ПРОБЕЛ") {
			(*ind)++;
			return state_space3(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "БУКВА") {
			*curState = ID2;
			return state_id2(symb, value, curState, ind, tkn);
		}
		return -1;
	}
	return -1;
}

int state_id2(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString) {
	if (*curState == ID2) {
		if (value[*ind] == "БУКВА" || value[*ind] == "ПОДЧЕРК" || value[*ind] == "ЦИФРА" && curString != "") {
			curString.push_back(symb[*ind]);
			(*ind)++;
			return state_id2(symb, value, curState, ind, tkn, curString);
		}
		if (curString != "" && value[*ind] == "ПРОБЕЛ" || value[*ind] == "ДВОЕТОЧИЕ") {
			if (value[*ind] == "ПРОБЕЛ") *curState = SPACE4;
			else *curState = COLON_EQUAL;
			tkn->input_string = curString;
			tkn->leks = "ИДЕНТИФИКАТОР";
			return 0;
		}
		return -1;
	}
	return -1;
}

int state_space4(char symb[], string value[], int* curState, int* ind, Token* tkn)
{
	if (*curState == SPACE4 || *curState == COLON_EQUAL) {
		if (value[*ind] == "ПРОБЕЛ") {
			(*ind)++;
			return state_space4(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "ДВОЕТОЧИЕ") {
			*curState = COLON_EQUAL;
			return state_colon_and_equal(symb, value, curState, ind, tkn);
		}
		return -1;
	}
	return -1;
}

int state_colon_and_equal(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString) {
	if (*curState == COLON_EQUAL) {
		if (curString == "" && value[*ind] == "ДВОЕТОЧИЕ") {
			curString.push_back(symb[*ind]);
			(*ind)++;
			return state_colon_and_equal(symb, value, curState, ind, tkn, curString);
		}
		if (curString.size() == 1 && value[*ind] == "РАВНО") {
			curString.push_back(symb[*ind]);
			(*ind)++;
			return state_colon_and_equal(symb, value, curState, ind, tkn, curString);
		}
		if (curString.size() == 2){
			if (value[*ind] == "ПРОБЕЛ") {
				(*ind)++;
				return state_colon_and_equal(symb, value, curState, ind, tkn, curString);
			}
			if (value[*ind] == "БУКВА") {
				*curState = NAME1;
				tkn->input_string = curString;
				tkn->leks = "ПРИСВОЕНИЕ";
				return 0; 
			}
			return -1;
		}
		return -1;
	}
	return -1;
}

int state_name1(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString) {
	if (*curState == NAME1) {
		if (value[*ind] == "БУКВА" || value[*ind] == "ПОДЧЕРК" || value[*ind] == "ЦИФРА" && curString != "") {
			curString.push_back(symb[*ind]);
			(*ind)++;
			return state_name1(symb, value, curState, ind, tkn, curString);
		}
		if (curString != "" && value[*ind] == "ОСКОБКА") {
			*curState = ID3;
			(*ind)++;
			tkn->input_string = curString;
			tkn->leks = "ПОДПРОГРАММА";
			return 0;
		}
		return -1;
	}
	return -1;
}

int state_id3(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString)
{
	if (*curState == ID3) {
		if (value[*ind] == "БУКВА" || value[*ind] == "ПОДЧЕРК" || value[*ind] == "ЦИФРА" && curString != "") {
			curString.push_back(symb[*ind]);
			(*ind)++;
			return state_id3(symb, value, curState, ind, tkn, curString);
		}
		if (curString != "" && value[*ind] == "ЗСКОБКА") {
			*curState = CBRACKET1;
			(*ind)++;
			tkn->input_string = curString;
			tkn->leks = "ИДЕНТИФИКАТОР";
			return 0;
		}
		return -1;
	}
	return -1;
}

int state_cbracket1(char symb[], string value[], int* curState, int* ind, Token* tkn)
{
	if (*curState == CBRACKET1) {
		if (value[*ind] == "ПРОБЕЛ")
		{
			*curState = SPACE5;
			return state_space5(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "ТЧКЗПТ")
		{
			*curState = SEMICOLON;
			(*ind)++;
			tkn->input_string = ";";
			tkn->leks = "ТЧКЗПТ";
			return 0;
		}
		return -1;
	}
	return -1;
}


int state_space5(char symb[], string value[], int* curState, int* ind, Token* tkn)
{
	if (*curState == SPACE5) {
		if (value[*ind] == "ПРОБЕЛ")
		{
			(*ind)++;
			return state_space5(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "ТЧКЗПТ")
		{
			*curState = SEMICOLON;
			return state_semicolon(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "БУКВА")
		{
			*curState = ELSE;
			return state_else(symb, value, curState, ind, tkn);
		}
		return -1;
	}
	return -1;
}

int state_else(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString)
{
	if (*curState == ELSE) {
		if (curString.size() == 4 && value[*ind] == "ПРОБЕЛ")
		{
			*curState = SPACE6;
			tkn->input_string = curString;
			tkn->leks = "ИДЕНТИФИКАТОР";
			return 0;
		}
		if (value[*ind] == "БУКВА")
		{
			switch ((char)tolower(symb[*ind])) {
				case 'l': if (curString.size() != 1) return -1;
					break;
				case 's': if (curString.size() != 2) return -1;
					break;
				default:
				// пришло е и перед ним есть s или пробел
					if ((char)tolower(symb[*ind]) == 'e' && (curString.size() != 0 && 
						(char)tolower(symb[(*ind)-1]) == 's' || curString.size() == 0))
						break;
					return -1;
			}
			curString.push_back(symb[*ind]);
			*ind += 1;
			return state_else(symb, value, curState, ind, tkn, curString);
		}
		return -1;
	}
	return -1;
}

int state_space6(char symb[], string value[], int* curState, int* ind, Token* tkn)
{
	if (*curState == SPACE6) {
		if (value[*ind] == "ПРОБЕЛ")
		{
			(*ind)++;
			return state_space6(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "БУКВА")
		{
			*curState = NAME2;
			return state_name2(symb, value, curState, ind, tkn);
		}
		return -1;
	}
	return -1;
}

int state_name2(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString)
{
	if (*curState == NAME2) {
		if (value[*ind] == "БУКВА" || value[*ind] == "ПОДЧЕРК" || value[*ind] == "ЦИФРА" && curString != "") {
			curString.push_back(symb[*ind]);
			(*ind)++;
			return state_name2(symb, value, curState, ind, tkn, curString);
		}
		if (curString != "" && value[*ind] == "ОСКОБКА") {
			*curState = SIGN_INT;
			(*ind)++;
			tkn->input_string = curString;
			tkn->leks = "ПОДПРОГРАММА";
			return 0;
		}
		return -1;
	}
	return -1;
}

int state_sign_and_int(char symb[], string value[], int* curState, int* ind, Token* tkn, string curString)
{
	if (*curState == SIGN_INT) {
		if (curString == "" && value[*ind] == "ЗНАК") {
			curString.push_back(symb[*ind]);
			(*ind)++;
			return state_sign_and_int(symb, value, curState, ind, tkn, curString);
		}
		if (value[*ind] == "ЦИФРА") {
			curString.push_back(symb[*ind]);
			(*ind)++;
			return state_sign_and_int(symb, value, curState, ind, tkn, curString);
		}
		if (value[*ind] == "ЗСКОБКА")
		{
			*curState = CBRACKET2;
			(*ind)++;
			tkn->input_string = curString;
			tkn->leks = "ЦЕЛОЕ";
			return 0;
		}
		return -1;
	}
	return -1;
}

int state_cbracket2(char symb[], string value[], int* curState, int* ind, Token* tkn)
{
	if (*curState == CBRACKET2) {
		if (value[*ind] == "ПРОБЕЛ")
		{
			(*ind)++;
			return state_cbracket2(symb, value, curState, ind, tkn);
		}
		if (value[*ind] == "ТЧКЗПТ")
		{
			*curState = SEMICOLON;
			(*ind)++;
			tkn->input_string = ";";
			tkn->leks = "ТЧКЗПТ";
			return 0;
		}
		return -1;
	}
	return -1;
}

int state_semicolon(char symb[], string value[], int* curState, int* ind, Token* tkn)
{
	if (*curState == SEMICOLON && value[*ind] == "ПРОБЕЛ") {
		(*ind)++;
		return state_semicolon(symb, value, curState, ind, tkn);
	}
	if (value[*ind] == "") return 0;
	return -1;
}